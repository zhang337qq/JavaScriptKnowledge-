# 	Ajax（ **A***synchronous* **J***avascript* ***A****nd* **X***ML*）

异步







​     **JS 是单线程的语言**，所谓“单线程”就是一根筋，对于拿到的程序，一行一行的执行，上面的执行为完成，就傻傻的等着。例如：

var i, t = Date.now()

for (i = 0; i < 100000000; i++) {

}

console.log(Date.now() - t) // 254 （chrome浏览器）



上面的程序花费 254ms 的时间执行完成，执行过程中就会有卡顿，其他的事儿就先撂一边不管了。

执行程序这样没有问题，但是对于 JS 最初使用的环境 ———— 浏览器客户端 ———— 就不一样了。因此在浏览器端运行的 js ，可能会有大量的网络请求，**而一个网络资源啥时候返回，这个时间是不可预估的。这种情况也要傻傻的等着、卡顿着、啥都不做吗？**———— 那肯定不行。

因此，JS 对于这种场景就设计了异步 -— 即，发起一个网络请求，就先不管这边了，先干其他事儿，网络请求啥时候返回结果，到时候再说。这样就能保证一个网页的流程运行。

服务器：代码上线就是上传到服务器

Ajax 这个概念是由 JesseJamesGarrett 在 2005 年发明的。它本身不是单一技术，是一串 技术的集合，主要有：



1.JavaScript，通过用户或其他与浏览器相关事件捕获交互行为



2.XMLHttpRequest 对象，通过这个对象可以在不中断其它浏览器任务的情况下向服务 器发送请求；



3.服务器上的文件，以 XML、HTML 或 JSON 格式保存文本数据；



4.其它 JavaScript，解释来自服务器的数据（比如 PHP 从 MySQL 获取的数据）并将其 呈现到页面上。



由于 Ajax 包含众多特性，优势与不足也非常明显。优势主要以下几点：



1.不需要插件支持（一般浏览器且默认开启 JavaScript 即可）；



2.用户体验极佳（不刷新页面即可获取可更新的数据）；



3.提升 Web 程序的性能（在传递数据方面做到按需放松，不必整体提交）；



4.减轻服务器和带宽的负担（将服务器的一些操作转移到客户端）；



而 Ajax 的不足由以下几点：

1.不同版本的浏览器度 XMLHttpRequest 对象支持度不足(比如 IE5 之前)； 

2.前进、后退的功能被破坏（因为 Ajax 永远在当前页，不会记录前后页面）；

3.搜索引擎的支持度不够（因为搜索引擎爬虫还不能理解 JS 引起变化数据的内容）；


JSON (Javascript Object Notation, JS 对象标记) 

{

​    "name":"张三",

​    "age":18,

​    "like":["抽烟","喝酒","烫头"]

}

XML

 

<person>

​    <name>张三</name>

​    <age>18</age>

​    <like>

​        <item>抽烟</item>

​        <item>喝酒</item>

​        <item>烫头</item>

​    </like>

</person>


json是一种数据格式，由对象，数组互相嵌套组成，属性名必须加双引号，数据传输格式









var ajax = new XMLHttpRequest();

ajax.open("GET","url",true); //get请求，url请求地址，true代表异步

ajax.send();

ajax.onreadystatechange = function(){

​    if(ajax.readyState == 4 && ajax.status == 200{

​        console.log(ajax.responseText);

​     }

}

xhr.readyState



0 － （未初始化）还没有调用send()方法



1 － （载入）已调用send()方法，正在发送请求



2 － （载入完成）send()方法执行完成，已经接收到全部响应内容



3 － （交互）正在解析响应内容



4 － （完成）响应内容解析完成，可以在客户端调用了

HTTP 状态码 xhr.status



AJAX状态码说明



**1\**：请求收到，继续处理**

**2\**：操作成功收到，分析、接受**

**3\**：完成此请求必须进一步处理**

**4\**：请求包含一个错误语法或不能完成**

**5\**：服务器执行一个完全有效请求失败**



100——客户必须继续发出请求



**101——客户要求服务器根据请求转换HTTP协议版本**



**200——交易成功**



201——提示知道新文件的URL     



202——接受和处理、但处理未完成



203——返回信息不确定或不完整



204——请求收到，但返回信息为空



205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件



206——服务器已经完成了部分用户的GET请求



300——请求的资源可在多处得到



301——删除请求数据



302——在其他地址发现了请求数据



303——建议客户访问其他URL或访问方式



**304——客户端已经执行了GET，但文件未变化**



305——请求的资源必须从服务器指定的地址得到



**306——前一版本HTTP中使用的代码，现行版本中不再使用**



307——申明请求的资源临时性删除



**400——错误请求，如语法错误**



401——请求授权失败



402——保留有效ChargeTo头响应



**403——请求不允许**



**404——没有发现文件、查询或URl**



**405——用户在Request-Line字段定义的方法不允许**



406——根据用户发送的Accept拖，请求资源不可访问



407——类似401，用户必须首先在代理服务器上得到授权



408——客户端没有在用户指定的饿时间内完成请求



409——对当前资源状态，请求不能完成



410——服务器上不再有此资源且无进一步的参考地址



411——服务器拒绝用户定义的Content-Length属性请求



412——一个或多个请求头字段在当前请求中错误



413——请求的资源大于服务器允许的大小



414——请求的资源URL长于服务器允许的长度



415——请求资源不支持请求项目格式



416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段



417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求



**500——服务器产生内部错误**



501——服务器不支持请求的函数



502——服务器暂时不可用，有时是为了防止发生系统过载



**503——服务器过载或暂停维修**



504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长



**505——服务器不支持或拒绝支请求头中指定的HTTP版本**

GET，POST



   只是不同的发送和请求数据的方式

| GET                                                       | POST         |
| --------------------------------------------------------- | ------------ |
| 参数有长度限制                                            | 无限制       |
| [http://www.taobao.com?id=3](http://www.taobao.com/?id=3) | 放在请求体里 |
| 明文传输                                                  | 更安全       |

## **浏览器的同源策略：**

 浏览器安全策略，保障非同源资源之间数据访问的安全性。

​    默认不允许非同源的资源直接访问。

​    URL：

​        协议://域名:端口/路径名称?查询字符串#位置标识符

​    同源：**协议、域名、端口**完全一致，只要三个中有任何一个不一致，则是非同源



​    非同源资源间需要进行访问，则需要实现跨域。



解决资源跨域访问：

​    a. CORS

​        cross-origin resource sharing

​        服务器端：

​            设置响应头信息：        Access-Control-Allow-Origin:*

​        前端：

​            ajax

​        可解决GET/POST跨域需求



​    b. jsonp

        <script src=""></script>

​        利用<script>在引入外部JS时不受同源策略限制的特性，来实现跨域。(src的开放性原则)

​        JSONP只能处理GET请求方式的跨域



​        后端：

​            由服务器端构建一个字符串：字符串中的内容是能够在 JS 中执行的函数调用的结构

​        前端：

​            \1. 创建 <script> 元素

​            \2. 设置 src 属性，传递 callback 参数指明全局回调函数的名称

​            \3. 添加到 body 中

​            \4. 创建全局函数，用于处理响应数据

​            \5. 删除 <script> 元素



​    c.   ..........

### JSONP接口：

​    百度：<https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=>关键字&cb=回调函数名

## **promise（ES6）**


    承诺：--->  兑现 （resolve）  或  失信（rejected）



​    这个对象有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。


  

Promise对象(ES6)：

​    用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。它允许你为异步操作的成功和失败分别绑定相应的处理方法。这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象。

​    一个 Promise有以下几种状态:

​        pending: 初始状态，既不是成功，也不是失败状态。

​        fulfilled: 意味着操作成功完成。

​        rejected: 意味着操作失败。



​    创建Promise对象：

​        var promise = new Promise( executor );

​            executor: 是一个函数，该函数在创建Promise对象的同时被调用执行。

​            executor:

​                语法：function(resolve, reject) {...}

​                --resolve：将Promise对象状态修改为 fulfilled，可以传递参数到then方法的第一个函数中

​                --reject：将Promise对象状态修改为 rejected，可以传递参数到 then 方法的第二个函数中



​    API：

​        Promise.prototype.then(onfulfilled, onrejected) 方法：

​            -- onfulfilled 绑定的是成功时执行的函数

​            -- onrejected 绑定的是失败时执行的函数



​        Promise.all(iterable)

​            -- iterable : 可迭代对象（数组）

​            -- 返回Promise对象

​            -- 当数组中所有Promise对象都完成时，回调执行成功的函数，当只要有一个执行失败时，就回调执行失败的函数。



var promise1 = Promise.resolve(3);

var promise2 = 42;

var promise3 = new Promise(function(resolve, reject) {

  setTimeout(resolve, 100, 'foo');

});



Promise.all([promise1, promise2, promise3]).then(function(values) {

  console.log(values);

});